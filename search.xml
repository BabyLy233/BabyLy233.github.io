<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java语言基础:异常</title>
      <link href="2021/02/22/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/"/>
      <url>2021/02/22/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在 Java 语言中，将程序执行中发生的不正常情况称为 “异常” （开发过程中的语法错误和逻辑错误不是异常）</p><p>Java 程序在执行过程中所发生的异常事件可分为两类：</p><ul><li>Error ：Java虚拟机无法解决的严重问题。如 JVM 系统内部错误、资源耗尽等严重情况。比如：<font color="red">StackOverflowError</font> 和 <font color="red">OOM</font> 。一般 不编写针对性的代码进行处理。例如：<ul><li>栈溢出：java.lang.StackOverflowError</li></ul></li><li>Exception ： 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：<ul><li>空指针访问</li><li>试图读取不存在的文件</li><li>网络连接中断</li><li>数组角标越界</li></ul></li></ul><blockquote><p>Java异常的体系结构</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/22/Bdo5z0.png" alt="异常体系结构"></p><h2 id="二、异常处理机制——抓抛模型"><a href="#二、异常处理机制——抓抛模型" class="headerlink" title="二、异常处理机制——抓抛模型"></a>二、异常处理机制——抓抛模型</h2><p>过程一：“抛” —— 程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象以后，其后的代码不再执行。</p><p>关于异常对象的产生：</p><ol><li>系统自动生成的异常对象</li><li>手动地生成一个异常对象，并抛出（throws）</li></ol><p>过程二：“抓”——可以理解为异常的处理方式：① try - catch - finally        ② throws</p><h3 id="1-try-catch-finally"><a href="#1-try-catch-finally" class="headerlink" title="1. try-catch-finally"></a>1. try-catch-finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">1</span> 变量名<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">2</span> 变量名<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">3</span> 变量名<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式3</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-说明："><a href="#1-1-说明：" class="headerlink" title="1.1 说明："></a>1.1 说明：</h4><ol><li>finally 是可选的（详见1.2 finally 的使用）</li><li>使用 try 将可能出现异常的代码包装起来，在执行过程中一旦出现异常，我们就会生成一个对应异常类的对象，根据此对象的类型，去 catch 中进行匹配</li><li>一旦 try 中的异常对象匹配到某一个 catch 时，就进入 catch 中进行异常的处理。一旦处理完成，就跳出当前的 try - catch 结构（在没有写 finally 的情况下），继续执行其后的代码</li><li>catch 中的异常类型，如果没有子父类关系，则声明在前后的位置无所谓；如果满足子父类关系，则要求子类一定声明在父类之前，否则会报错</li><li>常用的异常对象处理方式：<ol><li>String getMessage( );</li><li>printStackTrace( );</li></ol></li><li>在 try 结构中声明的变量，在出了 try 结构以后，就不能再被调用</li><li> try - catch 结构可以嵌套</li></ol><blockquote><p>注1：使用 try-catch-finally 结构处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 try-catch-finally 将一个编译时可能出现的异常，延迟到运行时出现</p><p>注2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 try - catch - finally 了。针对编译时异常，我们一定要考虑异常的处理</p></blockquote><h4 id="1-2-finally-的使用"><a href="#1-2-finally-的使用" class="headerlink" title="1.2 finally 的使用"></a>1.2 finally 的使用</h4><ol><li>finally 是可选的</li><li>finally 中声明的是一定会被执行的代码。即使 catch 中又出现异常了，try 中有 return 语句，catch 中有 return 语句等情况</li><li>像数据库连接、输入输出流、网络编程 Socket 等资源，JVM是不能自动回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在 finally 中</li></ol><hr><h3 id="2-throws-异常类型"><a href="#2-throws-异常类型" class="headerlink" title="2. throws + 异常类型"></a>2. throws + 异常类型</h3><ol><li><p>“throws + 异常类型” 写在方法的声明处。指明此方法执行时，可能抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 throws 后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</p></li><li><p>try-catch-finally 真正地将异常给处理掉了</p><p>throws 的方式只是将异常抛出给了方法的调用者，并没有将异常真正地处理掉</p></li></ol><hr><h3 id="3-方法重写的规则之一"><a href="#3-方法重写的规则之一" class="headerlink" title="3.方法重写的规则之一"></a>3.方法重写的规则之一</h3><p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p><h2 id="三、开发中如何选择异常处理的方法"><a href="#三、开发中如何选择异常处理的方法" class="headerlink" title="三、开发中如何选择异常处理的方法"></a>三、开发中如何选择异常处理的方法</h2><ol><li>如果父类中被重写的方法没有用 throws 方式处理异常，则子类重写的方法也不能使用 throws ， 意味着如果子类重写的方法中有异常，必须使用 try-catch-finally 方式处理</li><li>执行的方法中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用 throws 的方式进行处理。而执行的方法 a 可以使用 try-catch-finally 的方式进行处理</li></ol><h2 id="四、如何自定义异常"><a href="#四、如何自定义异常" class="headerlink" title="四、如何自定义异常"></a>四、如何自定义异常</h2><ol><li>继承于现有的异常结构：RuntimeException 、 Exception</li><li>提供全局常量：static final long serialVersionUID = -7034897190745766939L;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自己改一个UID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897190766939L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span> <span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 语言相关 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言高级:多线程</title>
      <link href="2021/02/22/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/02/22/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、多线程的创建"><a href="#一、多线程的创建" class="headerlink" title="一、多线程的创建"></a>一、多线程的创建</h2><h3 id="方式1：继承于Thread类"><a href="#方式1：继承于Thread类" class="headerlink" title="方式1：继承于Thread类"></a>方式1：继承于Thread类</h3><ol><li>创建一个继承于 Thread 类的子类</li><li>重写 Thread 类的 run()  —— 将此线程执行的操作声明在 run()中</li><li>创建 Thread 类的子类对象</li><li>通过此对象调用 start() ：① 启动当前线程；②调用当前线程的 run()</li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例子：遍历100以内所有的偶数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3.创建Thread类的子类对象</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 4.通过此对象调用start()</span></span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="comment">// 如下操作仍然是在main线程中执行的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread类的匿名子类的方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>我们不能直接通过调用 run() 的方式启动线程</p><h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>再启动一个线程，遍历100以内的偶数。不可以还让已经start()的线程去执行，否则会抛出IllegalThreadStateException异常<br>我们需要重新创建一个线程的对象，去调用start()</p><h3 id="Thread类中的常用方法"><a href="#Thread类中的常用方法" class="headerlink" title="Thread类中的常用方法"></a>Thread类中的常用方法</h3><ol><li>start()：启动当前线程；调用当前线程的run()</li><li>run()：通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li><li>currentThread()：静态方法，返回执行当前代码的线程</li><li>getName()：获取当前线程的名字</li><li>setName()：设置当前线程的名字</li><li>yield()：释放当前cpu的执行权</li><li>join()：在线程a中调用线程b的 join() ，此时线程a就进入阻塞状态，直到线程b完全被执行以后，线程a才结束阻塞状态</li><li><del>stop()</del>：<strong>已过时</strong>。当执行此方法时，强制结束当前线程</li><li>sleep(long millis)：让当前线程“睡眠”指定的millis毫秒。在指定的millis毫秒时间内，当前线程是阻塞状态</li><li>isAlive()：判断当前线程是否存活</li></ol><hr><h3 id="方式2：实现Runnable接口"><a href="#方式2：实现Runnable接口" class="headerlink" title="方式2：实现Runnable接口"></a>方式2：实现Runnable接口</h3><ol><li>创建一个实现了 Runnable接口 的类</li><li>实现类去实现Runnable中的抽象方法：run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  例子：遍历100以内所有的偶数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建一个实现了 Runnable接口 的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 创建实现类的对象</span></span><br><span class="line">        MTest mTest = <span class="keyword">new</span> MTest();</span><br><span class="line">        <span class="comment">// 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(mTest);</span><br><span class="line">        <span class="comment">// 5. 通过Thread类的对象调用start()</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="以上两种方式的比较"><a href="#以上两种方式的比较" class="headerlink" title="以上两种方式的比较"></a>以上两种方式的比较</h3><p>开发中优先选择：实现Runnable接口的方式</p><p>原因：</p><ol><li>实现接口的方式没有类的单继承性的局限性</li><li>实现的方式更适合来处理多个线程有共享数据的情况</li></ol><p>联系：Thread类本身实现了Runnable接口</p><p>相同点：两种方式都需要重写run()，将线程要的逻辑声明在run()中</p><h3 id="lt-——JDK-5-0新增线程创建方式——-gt"><a href="#lt-——JDK-5-0新增线程创建方式——-gt" class="headerlink" title="&lt;——JDK 5.0新增线程创建方式——&gt;"></a>&lt;——JDK 5.0新增线程创建方式——&gt;</h3><h3 id="方式3：实现Callable接口"><a href="#方式3：实现Callable接口" class="headerlink" title="方式3：实现Callable接口"></a>方式3：实现Callable接口</h3><ol><li><p>创建一个实现Callable的实现类</p></li><li><p>实现call方法，将此线程需要执行的操作声明在call()中</p></li><li><p>创建Callable接口实现类的对象</p></li><li><p>将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</p></li><li><p>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</p></li><li><p>获取Callable中call方法的返回值</p><p>返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</strong></p><ol><li><p>call()可以有返回值的。</p></li><li><p>call()可以抛出异常，被外面的操作捕获，获取异常的信息</p></li><li><p>Callable是支持泛型的</p></li></ol><h3 id="方式4：使用线程池"><a href="#方式4：使用线程池" class="headerlink" title="方式4：使用线程池"></a>方式4：使用线程池</h3><ol><li>提供指定线程数量的线程池</li><li>执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</li><li>关闭连接池</li></ol><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p><p>corePoolSize：核心池的大小</p><p>maximumPoolSize：最大线程数</p><p>keepAliveTime：线程没有任务时最多保持多长时间后会终止</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/04/image-20210204024756300de5c1cf34a6d7d0a.png" alt="image-20210204024756300de5c1cf34a6d7d0a.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/04/image-20210204024816814ffd32b74048300e7.png" alt="image-20210204024816814ffd32b74048300e7.png"></p><h2 id="二、线程的优先级"><a href="#二、线程的优先级" class="headerlink" title="二、线程的优先级"></a>二、线程的优先级</h2><h3 id="线程的优先级等级"><a href="#线程的优先级等级" class="headerlink" title="线程的优先级等级"></a>线程的优先级等级</h3><ul><li>MAX_PRIORITY：10</li><li>MIN_PRIORITY：1</li><li>NORM_PRIORITY：5</li></ul><h3 id="涉及的方法"><a href="#涉及的方法" class="headerlink" title="涉及的方法"></a>涉及的方法</h3><ul><li>getPriority()：获取线程的优先级</li><li>setPriority(int p)：设置线程的优先级</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>高优先级的线程要抢占低优先级线程cpu的执行权，但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完毕以后，低优先级的线程才执行</p><h2 id="三、线程的生命周期"><a href="#三、线程的生命周期" class="headerlink" title="三、线程的生命周期"></a>三、线程的生命周期</h2><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/03/image-20210202185449551c05f4dcf561cea3f.png" alt="image-20210202185449551c05f4dcf561cea3f.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/03/image-202102021855157857501ffdc9e4f785e.png" alt="image-202102021855157857501ffdc9e4f785e.png"></p><h2 id="四、线程的安全问题"><a href="#四、线程的安全问题" class="headerlink" title="四、线程的安全问题"></a>四、线程的安全问题</h2><blockquote><p>举例：卖票的过程中，出现了重票、错票 —— 线程的安全问题</p></blockquote><h3 id="1-问题出现的原因"><a href="#1-问题出现的原因" class="headerlink" title="1.问题出现的原因"></a>1.问题出现的原因</h3><p>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。</p><h3 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h3><p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。</p><h3 id="3-在-Java-中，我们通过同步机制，来解决线程的安全问题"><a href="#3-在-Java-中，我们通过同步机制，来解决线程的安全问题" class="headerlink" title="3.在 Java 中，我们通过同步机制，来解决线程的安全问题"></a>3.在 Java 中，我们通过同步机制，来解决线程的安全问题</h3><h4 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器) &#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p>操作共享数据的代码，即为需要被同步的代码   <strong>（ 不能包含代码多了，也不能包含代码少了 ）</strong></p></li><li><p>共享数据：多个线程共同操作的变量</p></li><li><p>同步监视器，俗称：锁  ， 任何一个类的对象，都可以充当锁</p><p>要求：多个线程必须要共用同一把锁</p></li></ol><p>补充：</p><ol><li>在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器</li><li>在继承Thread类创建多线程的方式中，慎用this来充当同步监视器，考虑使用当前类充当同步监视器</li></ol><h4 id="方式二：同步方法"><a href="#方式二：同步方法" class="headerlink" title="方式二：同步方法"></a>方式二：同步方法</h4><p>如果操作共享数据的代码完整地声明在一个方法中，我们不妨将此方法声明为同步的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 同步方法的内部代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><p>同步方法仍然涉及到同步监视器，只是我们不需要显式的声明</p></li><li><p>非静态的同步方法，同步监视器是：this</p><p>静态的同步方法，同步监视器是：当前类本身</p></li></ol><h4 id="方式三：Lock锁-——-JDK-5-0-新增"><a href="#方式三：Lock锁-——-JDK-5-0-新增" class="headerlink" title="方式三：Lock锁  —— JDK 5.0 新增"></a>方式三：Lock锁  —— JDK 5.0 新增</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.声明ReentrantLock类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2.调用该对象的lock()方法</span></span><br><span class="line">        lock.lock;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//保证线程安全的代码</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 3.调用解锁方法unlock()</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/03/image-202102030249596854fd2bdfe4e43dad7.png" alt="image-202102030249596854fd2bdfe4e43dad7.png"></p><hr><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>同步的方式解决了线程的安全问题</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>操作同步代码时，只能有一个线程参与，其它线程等待。相当于是一个单线程的过程，效率低</p><h3 id="4-线程的死锁问题"><a href="#4-线程的死锁问题" class="headerlink" title="4.线程的死锁问题"></a>4.线程的死锁问题</h3><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>专门的算法、原则</li><li>尽量减少同步资源的定义</li><li>尽量避免嵌套同步</li></ul><h2 id="五、线程的通信"><a href="#五、线程的通信" class="headerlink" title="五、线程的通信"></a>五、线程的通信</h2><blockquote><p>线程通信的例子：</p><p>使用两个线程打印 1-100。线程1、线程2交替打印</p></blockquote><h3 id="1-涉及到的三个方法"><a href="#1-涉及到的三个方法" class="headerlink" title="1.涉及到的三个方法"></a>1.涉及到的三个方法</h3><ul><li>wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</li><li>notify()：一旦执行此方法，就会唤醒被wait()的一个线程。如果有多个线程被wait()，就唤醒优先级高的那一个</li><li>notifyAll()：一旦执行此方法，就会唤醒所有被wait()的线程</li></ul><h3 id="2-说明"><a href="#2-说明" class="headerlink" title="2.说明"></a>2.说明</h3><ol><li>wait()，notify()，notifyAll()  三个方法必须使用在同步代码块或同步方法中</li><li>以上三个方法的调用者，必须是同步代码块或同步方法中的同步监视器，否则会出现<font color="red"> IllegalMonitorStateException </font>异常</li><li>以上三个方法定义在 java.lang.Object 类中</li></ol><h3 id="3-sleep-和wait-的异同"><a href="#3-sleep-和wait-的异同" class="headerlink" title="3.sleep()和wait()的异同"></a>3.sleep()和wait()的异同</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol><li>一旦执行方法，都可以使得当前线程进入阻塞状态</li></ol><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol><li><p>两个方法声明的位置不同：</p><p>Thread类中声明sleep() ， Object类中声明wait()</p></li><li><p>调用的要求不同：</p><p>sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中</p></li><li><p>关于是否释放同步监视器：</p><p>如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 语言相关 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
