<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java语言高级-注解</title>
      <link href="2021/02/25/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E6%B3%A8%E8%A7%A3/"/>
      <url>2021/02/25/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、理解"><a href="#一、理解" class="headerlink" title="一、理解"></a>一、理解</h2><ol><li>JDK 5.0 新增的功能</li><li>Annotation 其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息</li><li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等</li></ol><hr><h2 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h2><h3 id="示例一："><a href="#示例一：" class="headerlink" title="示例一："></a>示例一：</h3><p><strong>生成文档相关的注解</strong></p><h3 id="示例二："><a href="#示例二：" class="headerlink" title="示例二："></a>示例二：</h3><p><strong>在编译时进行格式检查(JDK内置的三个基本注解)</strong></p><ul><li>@Override: 限定重写父类方法, 该注解只能用于方法</li><li>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</li><li>@SuppressWarnings: 抑制编译器警告</li></ul><h3 id="示例三："><a href="#示例三：" class="headerlink" title="示例三："></a>示例三：</h3><p><strong>跟踪代码依赖性，实现替代配置文件功能</strong></p><hr><h2 id="三、自定义注解"><a href="#三、自定义注解" class="headerlink" title="三、自定义注解"></a>三、自定义注解</h2><p><strong>参照@SuppressWarnings定义</strong></p><ol><li>注解声明为：@interface</li><li>内部定义成员，通常使用value表示</li><li>可以指定成员的默认值，使用default定义</li><li>如果自定义注解没有成员，表明是一个标识作用</li></ol><p>如果注解有成员，在使用注解时，需要指明成员的值</p><p>自定义注解必须配上注解的信息处理流程(使用反射)才有意义</p><p>自定义注解通过都会指明两个元注解：Retention、Target</p><hr><h2 id="四、JDK提供的4种元注解"><a href="#四、JDK提供的4种元注解" class="headerlink" title="四、JDK提供的4种元注解"></a>四、JDK提供的4种元注解</h2><p><strong>元注解：对现有的注解进行解释说明的注解</strong></p><ul><li><p>Retention：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为）\RUNTIME</p><p>只有声明为RUNTIME生命周期的注解，才能通过反射获取。</p></li><li><p>Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p></li></ul><p>——出现的频率较低——</p><ul><li>Documented:表示所修饰的注解在被javadoc解析时，保留下来</li><li>Inherited:被它修饰的 Annotation 将具有继承性</li></ul><hr><h2 id="五、通过反射获取注解信息"><a href="#五、通过反射获取注解信息" class="headerlink" title="五、通过反射获取注解信息"></a>五、通过反射获取注解信息</h2><p><strong>略，详见“反射”相关内容</strong></p><hr><h2 id="六、JDK8中注解的新特性"><a href="#六、JDK8中注解的新特性" class="headerlink" title="六、JDK8中注解的新特性"></a>六、JDK8中注解的新特性</h2><h3 id="1-可重复注解"><a href="#1-可重复注解" class="headerlink" title="1.可重复注解"></a>1.可重复注解</h3><ol><li>在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</li><li>MyAnnotation的Target和Retention等元注解与MyAnnotations相同</li></ol><h3 id="2-类型注解"><a href="#2-类型注解" class="headerlink" title="2.类型注解"></a>2.类型注解</h3><p>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）</p><p>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 语言相关 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言高级-枚举类</title>
      <link href="2021/02/25/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>2021/02/25/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、理解"><a href="#一、理解" class="headerlink" title="一、理解"></a>一、理解</h2><ol><li>类的对象只有有限个，确定的。我们称此类为枚举类</li><li>当需要定义一组常量时，强烈建议使用枚举类</li><li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式</li></ol><hr><h2 id="二、如何定义枚举类"><a href="#二、如何定义枚举类" class="headerlink" title="二、如何定义枚举类"></a>二、如何定义枚举类</h2><h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><p><strong>JDK5.0之前，自定义枚举类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season spring = Season.SPRING;</span><br><span class="line">        Season summer = Season.SUMMER;</span><br><span class="line">        Season autumn = Season.AUTUMN;</span><br><span class="line">        Season winter = Season.WINTER;</span><br><span class="line">        System.out.println(spring);</span><br><span class="line">        System.out.println(summer);</span><br><span class="line">        System.out.println(autumn);</span><br><span class="line">        System.out.println(winter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供当前枚举类的多个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.1其它诉求:获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.2其它诉求:提供toString();</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><p><strong>JDK5.0，可以使用enum关键字定义枚举类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season1 summer = Season1.SUMMER;</span><br><span class="line">        System.out.println(summer);</span><br><span class="line">        <span class="comment">// 定义的枚举类默认继承于 java.lang.Enum</span></span><br><span class="line">        System.out.println(Season1.class.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的多个对象</span></span><br><span class="line">    <span class="comment">//   多个对象之间用&quot;,&quot;隔开</span></span><br><span class="line">    <span class="comment">//   末尾对象以&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.私有化类的构造器</span></span><br><span class="line">    Season1(String seasonName, String seasonDesc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.其它诉求:获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、Enum类中的常用方法"><a href="#三、Enum类中的常用方法" class="headerlink" title="三、Enum类中的常用方法"></a>三、Enum类中的常用方法</h2><ol><li>values()：返回枚举类型的对象数组，该方法可以很方便地遍历所有的枚举值</li><li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的名称</li><li>toString()：返回当前枚举类对象常量的名称</li></ol><hr><h2 id="四、使用enum关键字定义的枚举类实现接口的情况"><a href="#四、使用enum关键字定义的枚举类实现接口的情况" class="headerlink" title="四、使用enum关键字定义的枚举类实现接口的情况"></a>四、使用enum关键字定义的枚举类实现接口的情况</h2><h3 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h3><p><strong>实现接口，在enum类中实现抽象方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season1</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    Season1(String seasonName, String seasonDesc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个季节&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a>情况二：</h3><p><strong>让枚举类的对象分别实现接口中的抽象方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season1</span> <span class="keyword">implements</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是春天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是夏天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是秋天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是冬天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    Season1(String seasonName, String seasonDesc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 语言相关 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言基础:异常</title>
      <link href="2021/02/22/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/"/>
      <url>2021/02/22/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在 Java 语言中，将程序执行中发生的不正常情况称为 “异常” （开发过程中的语法错误和逻辑错误不是异常）</p><p>Java 程序在执行过程中所发生的异常事件可分为两类：</p><ul><li>Error ：Java虚拟机无法解决的严重问题。如 JVM 系统内部错误、资源耗尽等严重情况。比如：<font color="red">StackOverflowError</font> 和 <font color="red">OOM</font> 。一般 不编写针对性的代码进行处理。例如：<ul><li>栈溢出：java.lang.StackOverflowError</li></ul></li><li>Exception ： 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：<ul><li>空指针访问</li><li>试图读取不存在的文件</li><li>网络连接中断</li><li>数组角标越界</li></ul></li></ul><blockquote><p>Java异常的体系结构</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/22/Bdo5z0.png" alt="异常体系结构"></p><h2 id="二、异常处理机制——抓抛模型"><a href="#二、异常处理机制——抓抛模型" class="headerlink" title="二、异常处理机制——抓抛模型"></a>二、异常处理机制——抓抛模型</h2><p>过程一：“抛” —— 程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象以后，其后的代码不再执行。</p><p>关于异常对象的产生：</p><ol><li>系统自动生成的异常对象</li><li>手动地生成一个异常对象，并抛出（throws）</li></ol><p>过程二：“抓”——可以理解为异常的处理方式：① try - catch - finally        ② throws</p><h3 id="1-try-catch-finally"><a href="#1-try-catch-finally" class="headerlink" title="1. try-catch-finally"></a>1. try-catch-finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">1</span> 变量名<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">2</span> 变量名<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">3</span> 变量名<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式3</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-说明："><a href="#1-1-说明：" class="headerlink" title="1.1 说明："></a>1.1 说明：</h4><ol><li>finally 是可选的（详见1.2 finally 的使用）</li><li>使用 try 将可能出现异常的代码包装起来，在执行过程中一旦出现异常，我们就会生成一个对应异常类的对象，根据此对象的类型，去 catch 中进行匹配</li><li>一旦 try 中的异常对象匹配到某一个 catch 时，就进入 catch 中进行异常的处理。一旦处理完成，就跳出当前的 try - catch 结构（在没有写 finally 的情况下），继续执行其后的代码</li><li>catch 中的异常类型，如果没有子父类关系，则声明在前后的位置无所谓；如果满足子父类关系，则要求子类一定声明在父类之前，否则会报错</li><li>常用的异常对象处理方式：<ol><li>String getMessage( );</li><li>printStackTrace( );</li></ol></li><li>在 try 结构中声明的变量，在出了 try 结构以后，就不能再被调用</li><li> try - catch 结构可以嵌套</li></ol><blockquote><p>注1：使用 try-catch-finally 结构处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 try-catch-finally 将一个编译时可能出现的异常，延迟到运行时出现</p><p>注2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 try - catch - finally 了。针对编译时异常，我们一定要考虑异常的处理</p></blockquote><h4 id="1-2-finally-的使用"><a href="#1-2-finally-的使用" class="headerlink" title="1.2 finally 的使用"></a>1.2 finally 的使用</h4><ol><li>finally 是可选的</li><li>finally 中声明的是一定会被执行的代码。即使 catch 中又出现异常了，try 中有 return 语句，catch 中有 return 语句等情况</li><li>像数据库连接、输入输出流、网络编程 Socket 等资源，JVM是不能自动回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在 finally 中</li></ol><hr><h3 id="2-throws-异常类型"><a href="#2-throws-异常类型" class="headerlink" title="2. throws + 异常类型"></a>2. throws + 异常类型</h3><ol><li><p>“throws + 异常类型” 写在方法的声明处。指明此方法执行时，可能抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 throws 后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</p></li><li><p>try-catch-finally 真正地将异常给处理掉了</p><p>throws 的方式只是将异常抛出给了方法的调用者，并没有将异常真正地处理掉</p></li></ol><hr><h3 id="3-方法重写的规则之一"><a href="#3-方法重写的规则之一" class="headerlink" title="3.方法重写的规则之一"></a>3.方法重写的规则之一</h3><p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p><h2 id="三、开发中如何选择异常处理的方法"><a href="#三、开发中如何选择异常处理的方法" class="headerlink" title="三、开发中如何选择异常处理的方法"></a>三、开发中如何选择异常处理的方法</h2><ol><li>如果父类中被重写的方法没有用 throws 方式处理异常，则子类重写的方法也不能使用 throws ， 意味着如果子类重写的方法中有异常，必须使用 try-catch-finally 方式处理</li><li>执行的方法中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用 throws 的方式进行处理。而执行的方法 a 可以使用 try-catch-finally 的方式进行处理</li></ol><h2 id="四、如何自定义异常"><a href="#四、如何自定义异常" class="headerlink" title="四、如何自定义异常"></a>四、如何自定义异常</h2><ol><li>继承于现有的异常结构：RuntimeException 、 Exception</li><li>提供全局常量：static final long serialVersionUID = -7034897190745766939L;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自己改一个UID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897190766939L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span> <span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 语言相关 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言高级:多线程</title>
      <link href="2021/02/22/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/02/22/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、多线程的创建"><a href="#一、多线程的创建" class="headerlink" title="一、多线程的创建"></a>一、多线程的创建</h2><h3 id="方式1：继承于Thread类"><a href="#方式1：继承于Thread类" class="headerlink" title="方式1：继承于Thread类"></a>方式1：继承于Thread类</h3><ol><li>创建一个继承于 Thread 类的子类</li><li>重写 Thread 类的 run()  —— 将此线程执行的操作声明在 run()中</li><li>创建 Thread 类的子类对象</li><li>通过此对象调用 start() ：① 启动当前线程；②调用当前线程的 run()</li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例子：遍历100以内所有的偶数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3.创建Thread类的子类对象</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 4.通过此对象调用start()</span></span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="comment">// 如下操作仍然是在main线程中执行的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread类的匿名子类的方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>我们不能直接通过调用 run() 的方式启动线程</p><h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>再启动一个线程，遍历100以内的偶数。不可以还让已经start()的线程去执行，否则会抛出IllegalThreadStateException异常<br>我们需要重新创建一个线程的对象，去调用start()</p><h3 id="Thread类中的常用方法"><a href="#Thread类中的常用方法" class="headerlink" title="Thread类中的常用方法"></a>Thread类中的常用方法</h3><ol><li>start()：启动当前线程；调用当前线程的run()</li><li>run()：通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li><li>currentThread()：静态方法，返回执行当前代码的线程</li><li>getName()：获取当前线程的名字</li><li>setName()：设置当前线程的名字</li><li>yield()：释放当前cpu的执行权</li><li>join()：在线程a中调用线程b的 join() ，此时线程a就进入阻塞状态，直到线程b完全被执行以后，线程a才结束阻塞状态</li><li><del>stop()</del>：<strong>已过时</strong>。当执行此方法时，强制结束当前线程</li><li>sleep(long millis)：让当前线程“睡眠”指定的millis毫秒。在指定的millis毫秒时间内，当前线程是阻塞状态</li><li>isAlive()：判断当前线程是否存活</li></ol><hr><h3 id="方式2：实现Runnable接口"><a href="#方式2：实现Runnable接口" class="headerlink" title="方式2：实现Runnable接口"></a>方式2：实现Runnable接口</h3><ol><li>创建一个实现了 Runnable接口 的类</li><li>实现类去实现Runnable中的抽象方法：run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  例子：遍历100以内所有的偶数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建一个实现了 Runnable接口 的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 创建实现类的对象</span></span><br><span class="line">        MTest mTest = <span class="keyword">new</span> MTest();</span><br><span class="line">        <span class="comment">// 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(mTest);</span><br><span class="line">        <span class="comment">// 5. 通过Thread类的对象调用start()</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="以上两种方式的比较"><a href="#以上两种方式的比较" class="headerlink" title="以上两种方式的比较"></a>以上两种方式的比较</h3><p>开发中优先选择：实现Runnable接口的方式</p><p>原因：</p><ol><li>实现接口的方式没有类的单继承性的局限性</li><li>实现的方式更适合来处理多个线程有共享数据的情况</li></ol><p>联系：Thread类本身实现了Runnable接口</p><p>相同点：两种方式都需要重写run()，将线程要的逻辑声明在run()中</p><h3 id="lt-——JDK-5-0新增线程创建方式——-gt"><a href="#lt-——JDK-5-0新增线程创建方式——-gt" class="headerlink" title="&lt;——JDK 5.0新增线程创建方式——&gt;"></a>&lt;——JDK 5.0新增线程创建方式——&gt;</h3><h3 id="方式3：实现Callable接口"><a href="#方式3：实现Callable接口" class="headerlink" title="方式3：实现Callable接口"></a>方式3：实现Callable接口</h3><ol><li><p>创建一个实现Callable的实现类</p></li><li><p>实现call方法，将此线程需要执行的操作声明在call()中</p></li><li><p>创建Callable接口实现类的对象</p></li><li><p>将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</p></li><li><p>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</p></li><li><p>获取Callable中call方法的返回值</p><p>返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</strong></p><ol><li><p>call()可以有返回值的。</p></li><li><p>call()可以抛出异常，被外面的操作捕获，获取异常的信息</p></li><li><p>Callable是支持泛型的</p></li></ol><h3 id="方式4：使用线程池"><a href="#方式4：使用线程池" class="headerlink" title="方式4：使用线程池"></a>方式4：使用线程池</h3><ol><li>提供指定线程数量的线程池</li><li>执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</li><li>关闭连接池</li></ol><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p><p>corePoolSize：核心池的大小</p><p>maximumPoolSize：最大线程数</p><p>keepAliveTime：线程没有任务时最多保持多长时间后会终止</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/04/image-20210204024756300de5c1cf34a6d7d0a.png" alt="image-20210204024756300de5c1cf34a6d7d0a.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/04/image-20210204024816814ffd32b74048300e7.png" alt="image-20210204024816814ffd32b74048300e7.png"></p><h2 id="二、线程的优先级"><a href="#二、线程的优先级" class="headerlink" title="二、线程的优先级"></a>二、线程的优先级</h2><h3 id="线程的优先级等级"><a href="#线程的优先级等级" class="headerlink" title="线程的优先级等级"></a>线程的优先级等级</h3><ul><li>MAX_PRIORITY：10</li><li>MIN_PRIORITY：1</li><li>NORM_PRIORITY：5</li></ul><h3 id="涉及的方法"><a href="#涉及的方法" class="headerlink" title="涉及的方法"></a>涉及的方法</h3><ul><li>getPriority()：获取线程的优先级</li><li>setPriority(int p)：设置线程的优先级</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>高优先级的线程要抢占低优先级线程cpu的执行权，但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完毕以后，低优先级的线程才执行</p><h2 id="三、线程的生命周期"><a href="#三、线程的生命周期" class="headerlink" title="三、线程的生命周期"></a>三、线程的生命周期</h2><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/03/image-20210202185449551c05f4dcf561cea3f.png" alt="image-20210202185449551c05f4dcf561cea3f.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/03/image-202102021855157857501ffdc9e4f785e.png" alt="image-202102021855157857501ffdc9e4f785e.png"></p><h2 id="四、线程的安全问题"><a href="#四、线程的安全问题" class="headerlink" title="四、线程的安全问题"></a>四、线程的安全问题</h2><blockquote><p>举例：卖票的过程中，出现了重票、错票 —— 线程的安全问题</p></blockquote><h3 id="1-问题出现的原因"><a href="#1-问题出现的原因" class="headerlink" title="1.问题出现的原因"></a>1.问题出现的原因</h3><p>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。</p><h3 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h3><p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。</p><h3 id="3-在-Java-中，我们通过同步机制，来解决线程的安全问题"><a href="#3-在-Java-中，我们通过同步机制，来解决线程的安全问题" class="headerlink" title="3.在 Java 中，我们通过同步机制，来解决线程的安全问题"></a>3.在 Java 中，我们通过同步机制，来解决线程的安全问题</h3><h4 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器) &#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p>操作共享数据的代码，即为需要被同步的代码   <strong>（ 不能包含代码多了，也不能包含代码少了 ）</strong></p></li><li><p>共享数据：多个线程共同操作的变量</p></li><li><p>同步监视器，俗称：锁  ， 任何一个类的对象，都可以充当锁</p><p>要求：多个线程必须要共用同一把锁</p></li></ol><p>补充：</p><ol><li>在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器</li><li>在继承Thread类创建多线程的方式中，慎用this来充当同步监视器，考虑使用当前类充当同步监视器</li></ol><h4 id="方式二：同步方法"><a href="#方式二：同步方法" class="headerlink" title="方式二：同步方法"></a>方式二：同步方法</h4><p>如果操作共享数据的代码完整地声明在一个方法中，我们不妨将此方法声明为同步的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 同步方法的内部代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><p>同步方法仍然涉及到同步监视器，只是我们不需要显式的声明</p></li><li><p>非静态的同步方法，同步监视器是：this</p><p>静态的同步方法，同步监视器是：当前类本身</p></li></ol><h4 id="方式三：Lock锁-——-JDK-5-0-新增"><a href="#方式三：Lock锁-——-JDK-5-0-新增" class="headerlink" title="方式三：Lock锁  —— JDK 5.0 新增"></a>方式三：Lock锁  —— JDK 5.0 新增</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.声明ReentrantLock类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2.调用该对象的lock()方法</span></span><br><span class="line">        lock.lock;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//保证线程安全的代码</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 3.调用解锁方法unlock()</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://www.helloimg.com/images/2021/02/03/image-202102030249596854fd2bdfe4e43dad7.png" alt="image-202102030249596854fd2bdfe4e43dad7.png"></p><hr><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>同步的方式解决了线程的安全问题</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>操作同步代码时，只能有一个线程参与，其它线程等待。相当于是一个单线程的过程，效率低</p><h3 id="4-线程的死锁问题"><a href="#4-线程的死锁问题" class="headerlink" title="4.线程的死锁问题"></a>4.线程的死锁问题</h3><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>专门的算法、原则</li><li>尽量减少同步资源的定义</li><li>尽量避免嵌套同步</li></ul><h2 id="五、线程的通信"><a href="#五、线程的通信" class="headerlink" title="五、线程的通信"></a>五、线程的通信</h2><blockquote><p>线程通信的例子：</p><p>使用两个线程打印 1-100。线程1、线程2交替打印</p></blockquote><h3 id="1-涉及到的三个方法"><a href="#1-涉及到的三个方法" class="headerlink" title="1.涉及到的三个方法"></a>1.涉及到的三个方法</h3><ul><li>wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</li><li>notify()：一旦执行此方法，就会唤醒被wait()的一个线程。如果有多个线程被wait()，就唤醒优先级高的那一个</li><li>notifyAll()：一旦执行此方法，就会唤醒所有被wait()的线程</li></ul><h3 id="2-说明"><a href="#2-说明" class="headerlink" title="2.说明"></a>2.说明</h3><ol><li>wait()，notify()，notifyAll()  三个方法必须使用在同步代码块或同步方法中</li><li>以上三个方法的调用者，必须是同步代码块或同步方法中的同步监视器，否则会出现<font color="red"> IllegalMonitorStateException </font>异常</li><li>以上三个方法定义在 java.lang.Object 类中</li></ol><h3 id="3-sleep-和wait-的异同"><a href="#3-sleep-和wait-的异同" class="headerlink" title="3.sleep()和wait()的异同"></a>3.sleep()和wait()的异同</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol><li>一旦执行方法，都可以使得当前线程进入阻塞状态</li></ol><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol><li><p>两个方法声明的位置不同：</p><p>Thread类中声明sleep() ， Object类中声明wait()</p></li><li><p>调用的要求不同：</p><p>sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中</p></li><li><p>关于是否释放同步监视器：</p><p>如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 语言相关 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
